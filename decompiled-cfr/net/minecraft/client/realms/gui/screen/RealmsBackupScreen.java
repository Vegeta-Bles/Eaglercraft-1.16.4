/*
 * Decompiled with CFR 0.152.
 * 
 * Could not load the following classes:
 *  javax.annotation.Nullable
 *  org.apache.logging.log4j.LogManager
 *  org.apache.logging.log4j.Logger
 */
package net.minecraft.client.realms.gui.screen;

import com.mojang.blaze3d.systems.RenderSystem;
import java.text.DateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import javax.annotation.Nullable;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawableHelper;
import net.minecraft.client.gui.screen.ScreenTexts;
import net.minecraft.client.gui.widget.AlwaysSelectedEntryListWidget;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.realms.Realms;
import net.minecraft.client.realms.RealmsClient;
import net.minecraft.client.realms.RealmsLabel;
import net.minecraft.client.realms.RealmsObjectSelectionList;
import net.minecraft.client.realms.dto.Backup;
import net.minecraft.client.realms.dto.RealmsServer;
import net.minecraft.client.realms.exception.RealmsServiceException;
import net.minecraft.client.realms.gui.screen.RealmsBackupInfoScreen;
import net.minecraft.client.realms.gui.screen.RealmsConfigureWorldScreen;
import net.minecraft.client.realms.gui.screen.RealmsLongConfirmationScreen;
import net.minecraft.client.realms.gui.screen.RealmsLongRunningMcoTaskScreen;
import net.minecraft.client.realms.gui.screen.RealmsScreen;
import net.minecraft.client.realms.task.DownloadTask;
import net.minecraft.client.realms.task.RestoreTask;
import net.minecraft.client.realms.util.RealmsUtil;
import net.minecraft.client.resource.language.I18n;
import net.minecraft.client.util.math.MatrixStack;
import net.minecraft.text.Text;
import net.minecraft.text.TranslatableText;
import net.minecraft.util.Identifier;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class RealmsBackupScreen
extends RealmsScreen {
    private static final Logger LOGGER = LogManager.getLogger();
    private static final Identifier field_22686 = new Identifier("realms", "textures/gui/realms/plus_icon.png");
    private static final Identifier field_22687 = new Identifier("realms", "textures/gui/realms/restore_icon.png");
    private static final Text field_26471 = new TranslatableText("mco.backup.button.restore");
    private static final Text field_26472 = new TranslatableText("mco.backup.changes.tooltip");
    private static final Text field_26473 = new TranslatableText("mco.configure.world.backup");
    private static final Text field_26474 = new TranslatableText("mco.backup.nobackups");
    private static int lastScrollPosition = -1;
    private final RealmsConfigureWorldScreen parent;
    private List<Backup> backups = Collections.emptyList();
    @Nullable
    private Text toolTip;
    private BackupObjectSelectionList backupObjectSelectionList;
    private int selectedBackup = -1;
    private final int slotId;
    private ButtonWidget downloadButton;
    private ButtonWidget restoreButton;
    private ButtonWidget changesButton;
    private Boolean noBackups = false;
    private final RealmsServer serverData;
    private RealmsLabel titleLabel;

    public RealmsBackupScreen(RealmsConfigureWorldScreen parent, RealmsServer serverData, int slotId) {
        this.parent = parent;
        this.serverData = serverData;
        this.slotId = slotId;
    }

    @Override
    public void init() {
        this.client.keyboard.setRepeatEvents(true);
        this.backupObjectSelectionList = new BackupObjectSelectionList();
        if (lastScrollPosition != -1) {
            this.backupObjectSelectionList.setScrollAmount(lastScrollPosition);
        }
        new Thread(this, "Realms-fetch-backups"){
            final /* synthetic */ RealmsBackupScreen field_19755;
            {
                this.field_19755 = realmsBackupScreen;
                super(string);
            }

            public void run() {
                RealmsClient realmsClient = RealmsClient.createRealmsClient();
                try {
                    List<Backup> list = realmsClient.backupsFor((long)RealmsBackupScreen.method_21148((RealmsBackupScreen)this.field_19755).id).backups;
                    RealmsBackupScreen.method_25108(this.field_19755).execute(() -> {
                        RealmsBackupScreen.method_21152(this.field_19755, list);
                        RealmsBackupScreen.method_21150(this.field_19755, RealmsBackupScreen.method_21156(this.field_19755).isEmpty());
                        RealmsBackupScreen.method_21159(this.field_19755).clear();
                        for (Backup backup : RealmsBackupScreen.method_21156(this.field_19755)) {
                            RealmsBackupScreen.method_21159(this.field_19755).addEntry(backup);
                        }
                        RealmsBackupScreen.method_21161(this.field_19755);
                    });
                }
                catch (RealmsServiceException realmsServiceException) {
                    RealmsBackupScreen.method_21145().error("Couldn't request backups", (Throwable)realmsServiceException);
                }
            }
        }.start();
        this.downloadButton = this.addButton(new ButtonWidget(this.width - 135, RealmsBackupScreen.row(1), 120, 20, new TranslatableText("mco.backup.button.download"), buttonWidget -> this.downloadClicked()));
        this.restoreButton = this.addButton(new ButtonWidget(this.width - 135, RealmsBackupScreen.row(3), 120, 20, new TranslatableText("mco.backup.button.restore"), buttonWidget -> this.restoreClicked(this.selectedBackup)));
        this.changesButton = this.addButton(new ButtonWidget(this.width - 135, RealmsBackupScreen.row(5), 120, 20, new TranslatableText("mco.backup.changes.tooltip"), buttonWidget -> {
            this.client.openScreen(new RealmsBackupInfoScreen(this, this.backups.get(this.selectedBackup)));
            this.selectedBackup = -1;
        }));
        this.addButton(new ButtonWidget(this.width - 100, this.height - 35, 85, 20, ScreenTexts.BACK, buttonWidget -> this.client.openScreen(this.parent)));
        this.addChild(this.backupObjectSelectionList);
        this.titleLabel = this.addChild(new RealmsLabel(new TranslatableText("mco.configure.world.backup"), this.width / 2, 12, 0xFFFFFF));
        this.focusOn(this.backupObjectSelectionList);
        this.updateButtonStates();
        this.narrateLabels();
    }

    private void generateChangeList() {
        if (this.backups.size() <= 1) {
            return;
        }
        for (int i = 0; i < this.backups.size() - 1; ++i) {
            Backup backup = this.backups.get(i);
            _snowman = this.backups.get(i + 1);
            if (backup.metadata.isEmpty() || _snowman.metadata.isEmpty()) continue;
            for (String string : backup.metadata.keySet()) {
                if (!string.contains("Uploaded") && _snowman.metadata.containsKey(string)) {
                    if (backup.metadata.get(string).equals(_snowman.metadata.get(string))) continue;
                    this.addToChangeList(backup, string);
                    continue;
                }
                this.addToChangeList(backup, string);
            }
        }
    }

    private void addToChangeList(Backup backup, String key) {
        if (key.contains("Uploaded")) {
            String string = DateFormat.getDateTimeInstance(3, 3).format(backup.lastModifiedDate);
            backup.changeList.put(key, string);
            backup.setUploadedVersion(true);
        } else {
            backup.changeList.put(key, backup.metadata.get(key));
        }
    }

    private void updateButtonStates() {
        this.restoreButton.visible = this.shouldRestoreButtonBeVisible();
        this.changesButton.visible = this.shouldChangesButtonBeVisible();
    }

    private boolean shouldChangesButtonBeVisible() {
        if (this.selectedBackup == -1) {
            return false;
        }
        return !this.backups.get((int)this.selectedBackup).changeList.isEmpty();
    }

    private boolean shouldRestoreButtonBeVisible() {
        if (this.selectedBackup == -1) {
            return false;
        }
        return !this.serverData.expired;
    }

    @Override
    public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
        if (keyCode == 256) {
            this.client.openScreen(this.parent);
            return true;
        }
        return super.keyPressed(keyCode, scanCode, modifiers);
    }

    private void restoreClicked(int selectedBackup) {
        if (selectedBackup >= 0 && selectedBackup < this.backups.size() && !this.serverData.expired) {
            this.selectedBackup = selectedBackup;
            Date date = this.backups.get((int)selectedBackup).lastModifiedDate;
            String _snowman2 = DateFormat.getDateTimeInstance(3, 3).format(date);
            String _snowman3 = RealmsUtil.method_25282(date);
            TranslatableText _snowman4 = new TranslatableText("mco.configure.world.restore.question.line1", _snowman2, _snowman3);
            TranslatableText _snowman5 = new TranslatableText("mco.configure.world.restore.question.line2");
            this.client.openScreen(new RealmsLongConfirmationScreen(bl -> {
                if (bl) {
                    this.restore();
                } else {
                    this.selectedBackup = -1;
                    this.client.openScreen(this);
                }
            }, RealmsLongConfirmationScreen.Type.Warning, _snowman4, _snowman5, true));
        }
    }

    private void downloadClicked() {
        TranslatableText translatableText = new TranslatableText("mco.configure.world.restore.download.question.line1");
        _snowman = new TranslatableText("mco.configure.world.restore.download.question.line2");
        this.client.openScreen(new RealmsLongConfirmationScreen(bl -> {
            if (bl) {
                this.downloadWorldData();
            } else {
                this.client.openScreen(this);
            }
        }, RealmsLongConfirmationScreen.Type.Info, translatableText, _snowman, true));
    }

    private void downloadWorldData() {
        this.client.openScreen(new RealmsLongRunningMcoTaskScreen(this.parent.getNewScreen(), new DownloadTask(this.serverData.id, this.slotId, this.serverData.name + " (" + this.serverData.slots.get(this.serverData.activeSlot).getSlotName(this.serverData.activeSlot) + ")", this)));
    }

    private void restore() {
        Backup backup = this.backups.get(this.selectedBackup);
        this.selectedBackup = -1;
        this.client.openScreen(new RealmsLongRunningMcoTaskScreen(this.parent.getNewScreen(), new RestoreTask(backup, this.serverData.id, this.parent)));
    }

    @Override
    public void render(MatrixStack matrices, int mouseX, int mouseY, float delta) {
        this.toolTip = null;
        this.renderBackground(matrices);
        this.backupObjectSelectionList.render(matrices, mouseX, mouseY, delta);
        this.titleLabel.render(this, matrices);
        this.textRenderer.draw(matrices, field_26473, (float)((this.width - 150) / 2 - 90), 20.0f, 0xA0A0A0);
        if (this.noBackups.booleanValue()) {
            this.textRenderer.draw(matrices, field_26474, 20.0f, (float)(this.height / 2 - 10), 0xFFFFFF);
        }
        this.downloadButton.active = this.noBackups == false;
        super.render(matrices, mouseX, mouseY, delta);
        if (this.toolTip != null) {
            this.renderMousehoverTooltip(matrices, this.toolTip, mouseX, mouseY);
        }
    }

    protected void renderMousehoverTooltip(MatrixStack matrixStack, @Nullable Text text, int n, int n2) {
        if (text == null) {
            return;
        }
        _snowman = n + 12;
        _snowman = n2 - 12;
        _snowman = this.textRenderer.getWidth(text);
        this.fillGradient(matrixStack, _snowman - 3, _snowman - 3, _snowman + _snowman + 3, _snowman + 8 + 3, -1073741824, -1073741824);
        this.textRenderer.drawWithShadow(matrixStack, text, (float)_snowman, (float)_snowman, 0xFFFFFF);
    }

    static /* synthetic */ MinecraftClient method_25108(RealmsBackupScreen realmsBackupScreen) {
        return realmsBackupScreen.client;
    }

    static /* synthetic */ Logger method_21145() {
        return LOGGER;
    }

    static /* synthetic */ List method_21152(RealmsBackupScreen realmsBackupScreen, List list) {
        realmsBackupScreen.backups = list;
        return realmsBackupScreen.backups;
    }

    static /* synthetic */ Boolean method_21150(RealmsBackupScreen realmsBackupScreen, Boolean bl) {
        realmsBackupScreen.noBackups = bl;
        return realmsBackupScreen.noBackups;
    }

    static /* synthetic */ BackupObjectSelectionList method_21159(RealmsBackupScreen realmsBackupScreen) {
        return realmsBackupScreen.backupObjectSelectionList;
    }

    static /* synthetic */ void method_21161(RealmsBackupScreen realmsBackupScreen) {
        realmsBackupScreen.generateChangeList();
    }

    class BackupObjectSelectionListEntry
    extends AlwaysSelectedEntryListWidget.Entry<BackupObjectSelectionListEntry> {
        private final Backup mBackup;

        public BackupObjectSelectionListEntry(Backup backup) {
            this.mBackup = backup;
        }

        @Override
        public void render(MatrixStack matrices, int index, int y, int x, int entryWidth, int entryHeight, int mouseX, int mouseY, boolean hovered, float tickDelta) {
            this.renderBackupItem(matrices, this.mBackup, x - 40, y, mouseX, mouseY);
        }

        private void renderBackupItem(MatrixStack matrixStack, Backup backup, int n, int n2, int n3, int n4) {
            _snowman = backup.isUploadedVersion() ? -8388737 : 0xFFFFFF;
            RealmsBackupScreen.this.textRenderer.draw(matrixStack, "Backup (" + RealmsUtil.method_25282(backup.lastModifiedDate) + ")", (float)(n + 40), (float)(n2 + 1), _snowman);
            RealmsBackupScreen.this.textRenderer.draw(matrixStack, this.getMediumDatePresentation(backup.lastModifiedDate), (float)(n + 40), (float)(n2 + 12), 0x4C4C4C);
            _snowman = RealmsBackupScreen.this.width - 175;
            _snowman = -3;
            _snowman = _snowman - 10;
            boolean bl = false;
            if (!((RealmsBackupScreen)RealmsBackupScreen.this).serverData.expired) {
                this.drawRestore(matrixStack, _snowman, n2 + -3, n3, n4);
            }
            if (!backup.changeList.isEmpty()) {
                this.drawInfo(matrixStack, _snowman, n2 + 0, n3, n4);
            }
        }

        private String getMediumDatePresentation(Date lastModifiedDate) {
            return DateFormat.getDateTimeInstance(3, 3).format(lastModifiedDate);
        }

        private void drawRestore(MatrixStack matrixStack, int n, int n2, int n3, int n4) {
            boolean bl = n3 >= n && n3 <= n + 12 && n4 >= n2 && n4 <= n2 + 14 && n4 < RealmsBackupScreen.this.height - 15 && n4 > 32;
            RealmsBackupScreen.this.client.getTextureManager().bindTexture(field_22687);
            RenderSystem.color4f(1.0f, 1.0f, 1.0f, 1.0f);
            RenderSystem.pushMatrix();
            RenderSystem.scalef(0.5f, 0.5f, 0.5f);
            float _snowman2 = bl ? 28.0f : 0.0f;
            DrawableHelper.drawTexture(matrixStack, n * 2, n2 * 2, 0.0f, _snowman2, 23, 28, 23, 56);
            RenderSystem.popMatrix();
            if (bl) {
                RealmsBackupScreen.this.toolTip = field_26471;
            }
        }

        private void drawInfo(MatrixStack matrixStack, int n, int n2, int n3, int n4) {
            boolean bl = n3 >= n && n3 <= n + 8 && n4 >= n2 && n4 <= n2 + 8 && n4 < RealmsBackupScreen.this.height - 15 && n4 > 32;
            RealmsBackupScreen.this.client.getTextureManager().bindTexture(field_22686);
            RenderSystem.color4f(1.0f, 1.0f, 1.0f, 1.0f);
            RenderSystem.pushMatrix();
            RenderSystem.scalef(0.5f, 0.5f, 0.5f);
            float _snowman2 = bl ? 15.0f : 0.0f;
            DrawableHelper.drawTexture(matrixStack, n * 2, n2 * 2, 0.0f, _snowman2, 15, 15, 15, 30);
            RenderSystem.popMatrix();
            if (bl) {
                RealmsBackupScreen.this.toolTip = field_26472;
            }
        }
    }

    class BackupObjectSelectionList
    extends RealmsObjectSelectionList<BackupObjectSelectionListEntry> {
        public BackupObjectSelectionList() {
            super(RealmsBackupScreen.this.width - 150, RealmsBackupScreen.this.height, 32, RealmsBackupScreen.this.height - 15, 36);
        }

        public void addEntry(Backup backup) {
            this.addEntry(new BackupObjectSelectionListEntry(backup));
        }

        @Override
        public int getRowWidth() {
            return (int)((double)this.width * 0.93);
        }

        @Override
        public boolean isFocused() {
            return RealmsBackupScreen.this.getFocused() == this;
        }

        @Override
        public int getMaxPosition() {
            return this.getItemCount() * 36;
        }

        @Override
        public void renderBackground(MatrixStack matrices) {
            RealmsBackupScreen.this.renderBackground(matrices);
        }

        @Override
        public boolean mouseClicked(double mouseX, double mouseY, int button) {
            if (button != 0) {
                return false;
            }
            if (mouseX < (double)this.getScrollbarPositionX() && mouseY >= (double)this.top && mouseY <= (double)this.bottom) {
                int n = this.width / 2 - 92;
                _snowman = this.width;
                _snowman = (int)Math.floor(mouseY - (double)this.top) - this.headerHeight + (int)this.getScrollAmount();
                _snowman = _snowman / this.itemHeight;
                if (mouseX >= (double)n && mouseX <= (double)_snowman && _snowman >= 0 && _snowman >= 0 && _snowman < this.getItemCount()) {
                    this.setSelected(_snowman);
                    this.itemClicked(_snowman, _snowman, mouseX, mouseY, this.width);
                }
                return true;
            }
            return false;
        }

        @Override
        public int getScrollbarPositionX() {
            return this.width - 5;
        }

        @Override
        public void itemClicked(int cursorY, int selectionIndex, double mouseX, double mouseY, int listWidth) {
            int n = this.width - 35;
            _snowman = selectionIndex * this.itemHeight + 36 - (int)this.getScrollAmount();
            _snowman = n + 10;
            _snowman = _snowman - 3;
            if (mouseX >= (double)n && mouseX <= (double)(n + 9) && mouseY >= (double)_snowman && mouseY <= (double)(_snowman + 9)) {
                if (!((Backup)((RealmsBackupScreen)RealmsBackupScreen.this).backups.get((int)selectionIndex)).changeList.isEmpty()) {
                    RealmsBackupScreen.this.selectedBackup = -1;
                    lastScrollPosition = (int)this.getScrollAmount();
                    this.client.openScreen(new RealmsBackupInfoScreen(RealmsBackupScreen.this, (Backup)RealmsBackupScreen.this.backups.get(selectionIndex)));
                }
            } else if (mouseX >= (double)_snowman && mouseX < (double)(_snowman + 13) && mouseY >= (double)_snowman && mouseY < (double)(_snowman + 15)) {
                lastScrollPosition = (int)this.getScrollAmount();
                RealmsBackupScreen.this.restoreClicked(selectionIndex);
            }
        }

        @Override
        public void setSelected(int index) {
            this.setSelectedItem(index);
            if (index != -1) {
                Realms.narrateNow(I18n.translate("narrator.select", ((Backup)((RealmsBackupScreen)RealmsBackupScreen.this).backups.get((int)index)).lastModifiedDate.toString()));
            }
            this.selectInviteListItem(index);
        }

        public void selectInviteListItem(int item) {
            RealmsBackupScreen.this.selectedBackup = item;
            RealmsBackupScreen.this.updateButtonStates();
        }

        @Override
        public void setSelected(@Nullable BackupObjectSelectionListEntry backupObjectSelectionListEntry) {
            super.setSelected(backupObjectSelectionListEntry);
            RealmsBackupScreen.this.selectedBackup = this.children().indexOf(backupObjectSelectionListEntry);
            RealmsBackupScreen.this.updateButtonStates();
        }
    }
}

